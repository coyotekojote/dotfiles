# Skill作成ベストプラクティス詳細ガイド

このファイルは、効果的なSkillを作成するための詳細なベストプラクティスを提供します。

## 目次

- コンテキストウィンドウの効率的な使用
- 段階的情報開示の詳細
- ワークフローとフィードバックループ
- 実行可能コード付きSkillの設計
- 評価とテスト
- アンチパターン
- 技術的な注意事項

---

## コンテキストウィンドウの効率的な使用

### コンテキストウィンドウは公共財

コンテキストウィンドウは以下と共有されます:
- システムプロンプト
- 会話履歴
- 他のSkillsのメタデータ
- ユーザーの実際のリクエスト

### トークンコストの理解

**起動時**: すべてのSkillsのメタデータ（nameとdescription）のみがプリロードされる

**Skill発動時**: SKILL.mdが読み込まれる

**必要に応じて**: 参照ファイルが読み込まれる

→ SKILL.mdが簡潔であることは重要だが、参照ファイルは必要に応じて読み込まれるため、コンテキストへの即時的な影響は少ない

### 簡潔さのテスト

各段落について自問:
- 「Claudeは本当にこれを知らないか?」
- 「これはClaudeがすでに理解している概念か?」
- 「このトークンコストは正当化されるか?」

**削除すべき内容の例**:
- 一般的なプログラミング概念の説明（「変数とは...」など）
- 広く知られたファイル形式の説明（「JSONは...」など）
- 基本的なツールの使い方（「pipは...」など）

**保持すべき内容の例**:
- プロジェクト固有のルール
- ドメイン固有の知識
- 特定のワークフロー
- エッジケースの扱い

---

## 自由度の設定

### 高い自由度（テキストベースの指示）

**使用タイミング**:
- 複数のアプローチが有効
- 決定がコンテキストに依存
- ヒューリスティックがアプローチを導く

**例**:
```markdown
## コードレビュープロセス

1. コード構造と整理を分析
2. バグやエッジケースを確認
3. 可読性と保守性の改善を提案
4. プロジェクト規約への準拠を検証
```

**アナロジー**: 開けた野原で、多くの道が成功に導く

---

### 中程度の自由度（疑似コードやパラメータ付きスクリプト）

**使用タイミング**:
- 推奨パターンが存在
- 多少の変更が許容される
- 設定が動作に影響

**例**:
````markdown
## レポート生成

このテンプレートを使用し、必要に応じてカスタマイズ:

```python
def generate_report(data, format="markdown", include_charts=True):
    # データを処理
    # 指定形式で出力を生成
    # オプションで可視化を含める
```
````

---

### 低い自由度（具体的なスクリプト、パラメータなしまたは少数）

**使用タイミング**:
- 操作が脆弱でエラーが発生しやすい
- 一貫性が重要
- 特定のシーケンスに従う必要がある

**例**:
````markdown
## データベースマイグレーション

このスクリプトを正確に実行:

```bash
python scripts/migrate.py --verify --backup
```

コマンドを変更したり、追加のフラグを加えないでください。
````

**アナロジー**: 両側が崖の狭い橋で、安全に進む道は一つだけ

---

## 段階的情報開示の詳細

### 基本原則

**SKILL.mdは目次として機能**: 詳細な資料を指し示す概要

**500行ガイドライン**: SKILL.mdの本文は500行以内を目標

**1レベルの深さ**: 参照ファイルは常にSKILL.mdから直接リンク（深くネストしない）

### パターン1: 高レベルガイドと参照

````markdown
---
name: pdf-processing
description: PDFからテキストとテーブルを抽出、フォーム入力、文書結合。PDF、フォーム、文書抽出に言及された時に使用。
---

# PDF Processing

## クイックスタート

pdfplumberでテキスト抽出:
```python
import pdfplumber
with pdfplumber.open("file.pdf") as pdf:
    text = pdf.pages[0].extract_text()
```

## 高度な機能

**フォーム入力**: 完全なガイドは [FORMS.md](FORMS.md) を参照
**APIリファレンス**: すべてのメソッドは [REFERENCE.md](REFERENCE.md) を参照
**例**: 一般的なパターンは [EXAMPLES.md](EXAMPLES.md) を参照
````

**利点**:
- SKILL.mdは簡潔でスキャン可能
- Claudeは必要な時のみ詳細を読み込む
- トークン使用を最適化

---

### パターン2: ドメイン別の整理

**ディレクトリ構造**:
```
bigquery-skill/
├── SKILL.md (概要とナビゲーション)
└── reference/
    ├── finance.md (収益、請求メトリック)
    ├── sales.md (商談、パイプライン)
    ├── product.md (API使用、機能)
    └── marketing.md (キャンペーン、アトリビューション)
```

**SKILL.md**:
````markdown
# BigQuery データ分析

## 利用可能なデータセット

**Finance**: 収益、ARR、請求 → [reference/finance.md](reference/finance.md) を参照
**Sales**: 商談、パイプライン、アカウント → [reference/sales.md](reference/sales.md) を参照
**Product**: API使用、機能、採用 → [reference/product.md](reference/product.md) を参照
**Marketing**: キャンペーン、アトリビューション、メール → [reference/marketing.md](reference/marketing.md) を参照

## クイック検索

特定のメトリックを見つける:

```bash
grep -i "revenue" reference/finance.md
grep -i "pipeline" reference/sales.md
grep -i "api usage" reference/product.md
```
````

**利点**:
- 営業メトリックについての質問時、Claudeはsales.mdのみを読む
- 無関係なコンテキスト（finance、product）を避ける
- トークン使用を低く保ち、コンテキストを集中させる

---

### パターン3: 条件付き詳細

````markdown
# DOCX Processing

## ドキュメント作成

新しいドキュメントにはdocx-jsを使用。[DOCX-JS.md](DOCX-JS.md) を参照。

## ドキュメント編集

簡単な編集にはXMLを直接変更。

**変更履歴が必要な場合**: [REDLINING.md](REDLINING.md) を参照
**OOXML詳細が必要な場合**: [OOXML.md](OOXML.md) を参照
````

**利点**: Claudeはユーザーがこれらの機能を必要とする場合のみ、REDLINING.mdやOOXML.mdを読む

---

### 深くネストした参照を避ける

**悪い例（深すぎる）**:
```markdown
# SKILL.md
詳細は [advanced.md](advanced.md) を参照...

# advanced.md
詳細は [details.md](details.md) を参照...

# details.md
実際の情報がここに...
```

**問題**: Claudeはネストされた参照から参照されたファイルを部分的に読む可能性（`head -100`など）があり、情報が不完全になる

**良い例（1レベルの深さ）**:
```markdown
# SKILL.md

**基本的な使い方**: [SKILL.md内の説明]
**高度な機能**: [advanced.md](advanced.md) を参照
**APIリファレンス**: [reference.md](reference.md) を参照
**例**: [examples.md](examples.md) を参照
```

---

### 長い参照ファイルには目次を含める

**100行以上の参照ファイルの場合**:

```markdown
# APIリファレンス

## 目次
- 認証とセットアップ
- コアメソッド (作成、読取、更新、削除)
- 高度な機能 (バッチ操作、webhook)
- エラーハンドリングパターン
- コード例

## 認証とセットアップ
...

## コアメソッド
...
```

**利点**:
- Claudeが`head`で部分的にプレビューしても、利用可能な情報の全体像を把握できる
- 必要なセクションに直接ジャンプ可能

---

## ワークフローとフィードバックループ

### 複雑なタスクにワークフローを使用

**チェックリストパターン**:

````markdown
## PDF フォーム入力ワークフロー

このチェックリストをコピーして進捗を追跡:

```
タスク進捗:
- [ ] ステップ1: フォームを分析 (analyze_form.pyを実行)
- [ ] ステップ2: フィールドマッピングを作成 (fields.jsonを編集)
- [ ] ステップ3: マッピングを検証 (validate_fields.pyを実行)
- [ ] ステップ4: フォームを入力 (fill_form.pyを実行)
- [ ] ステップ5: 出力を検証 (verify_output.pyを実行)
```

**ステップ1: フォームを分析**

実行: `python scripts/analyze_form.py input.pdf`

これによりフォームフィールドとその位置が抽出され、`fields.json`に保存される。

**ステップ2: フィールドマッピングを作成**

`fields.json`を編集して各フィールドの値を追加。

**ステップ3: マッピングを検証**

実行: `python scripts/validate_fields.py fields.json`

続行前に検証エラーを修正。

**ステップ4: フォームを入力**

実行: `python scripts/fill_form.py input.pdf fields.json output.pdf`

**ステップ5: 出力を検証**

実行: `python scripts/verify_output.py output.pdf`

検証失敗時はステップ2に戻る。
````

**利点**:
- 明確なステップでClaudeが重要な検証をスキップするのを防ぐ
- チェックリストはClaudeとユーザーの両方が進捗を追跡するのを助ける

---

### フィードバックループを実装

**共通パターン**: バリデーターを実行 → エラーを修正 → 繰り返す

このパターンは出力品質を大幅に向上させます。

**例1: スタイルガイド準拠（コードなし）**:

```markdown
## コンテンツレビュープロセス

1. STYLE_GUIDE.mdのガイドラインに従ってコンテンツを下書き
2. チェックリストに対してレビュー:
   - 用語の一貫性を確認
   - 例が標準形式に従っているか確認
   - すべての必須セクションが存在するか確認
3. 問題が見つかった場合:
   - 各問題を特定のセクション参照とともに記録
   - コンテンツを修正
   - チェックリストを再度レビュー
4. すべての要件を満たした場合のみ次に進む
5. ドキュメントを確定して保存
```

**例2: ドキュメント編集プロセス（コード付き）**:

```markdown
## ドキュメント編集プロセス

1. `word/document.xml` を編集
2. **即座に検証**: `python ooxml/scripts/validate.py unpacked_dir/`
3. 検証失敗時:
   - エラーメッセージを注意深く確認
   - XMLの問題を修正
   - 検証を再実行
4. **検証成功時のみ次に進む**
5. 再構築: `python ooxml/scripts/pack.py unpacked_dir/ output.docx`
6. 出力ドキュメントをテスト
```

**利点**: 検証ループがエラーを早期に捕捉

---

## 実行可能コード付きSkillの設計

### 解決せよ、丸投げするな

**良い例（エラーを明示的に処理）**:

```python
def process_file(path):
    """ファイルを処理、存在しない場合は作成"""
    try:
        with open(path) as f:
            return f.read()
    except FileNotFoundError:
        # 失敗する代わりにデフォルトコンテンツでファイルを作成
        print(f"ファイル {path} が見つかりません、デフォルトを作成します")
        with open(path, 'w') as f:
            f.write('')
        return ''
    except PermissionError:
        # 失敗する代わりに代替手段を提供
        print(f"{path} にアクセスできません、デフォルトを使用します")
        return ''
```

**悪い例（Claudeに丸投げ）**:

```python
def process_file(path):
    # 失敗してClaudeに任せる
    return open(path).read()
```

---

### 設定パラメータの文書化

**良い例（自己文書化）**:

```python
# HTTPリクエストは通常30秒以内に完了
# より長いタイムアウトは遅い接続に対応
REQUEST_TIMEOUT = 30

# 3回の再試行が信頼性と速度のバランスを取る
# ほとんどの一時的な障害は2回目の再試行で解決
MAX_RETRIES = 3
```

**悪い例（魔法の数字）**:

```python
TIMEOUT = 47  # なぜ47?
RETRIES = 5   # なぜ5?
```

---

### ユーティリティスクリプトを提供

**Claudeがコードを書けるとしても、事前作成スクリプトには利点がある**:

**利点**:
- 生成されたコードより信頼性が高い
- トークンを節約（コンテキストにコードを含める必要なし）
- 時間を節約（コード生成不要）
- 使用間の一貫性を保証

**重要な区別**: 指示でClaudeが何をすべきか明確にする:
- **スクリプトを実行**（最も一般的）: "analyze_form.pyを実行してフィールドを抽出"
- **参照として読む**（複雑なロジックの場合）: "フィールド抽出アルゴリズムはanalyze_form.pyを参照"

**例**:

````markdown
## ユーティリティスクリプト

**analyze_form.py**: PDFからすべてのフォームフィールドを抽出

```bash
python scripts/analyze_form.py input.pdf > fields.json
```

出力形式:
```json
{
  "field_name": {"type": "text", "x": 100, "y": 200},
  "signature": {"type": "sig", "x": 150, "y": 500}
}
```

**validate_boxes.py**: 重なり合うバウンディングボックスをチェック

```bash
python scripts/validate_boxes.py fields.json
# 戻り値: "OK" または競合のリスト
```
````

---

### 視覚的分析を使用

**入力を画像としてレンダリングできる場合、Claudeに分析させる**:

````markdown
## フォームレイアウト分析

1. PDFを画像に変換:
   ```bash
   python scripts/pdf_to_images.py form.pdf
   ```

2. 各ページの画像を分析してフォームフィールドを識別
3. Claudeはフィールドの位置とタイプを視覚的に確認できる
````

Claudeの視覚能力はレイアウトと構造の理解を助けます。

---

### 検証可能な中間出力を作成

**「計画-検証-実行」パターン**:

複雑でオープンエンドのタスクでは、Claudeがミスをする可能性があります。このパターンは、Claudeにまず構造化形式で計画を作成させ、実行前にスクリプトでその計画を検証することで、エラーを早期に捕捉します。

**例**: スプレッドシートに基づいてPDFの50のフォームフィールドを更新するようClaudeに依頼する場合を想像してください。検証なしでは、Claudeは存在しないフィールドを参照したり、競合する値を作成したり、必須フィールドを見逃したり、更新を誤って適用したりする可能性があります。

**解決策**: ワークフローパターン（PDF フォーム入力）を使用し、変更を適用する前に検証される中間の`changes.json`ファイルを追加します。ワークフローは次のようになります: 分析 → **計画ファイルを作成** → **計画を検証** → 実行 → 確認。

**なぜこのパターンが機能するか**:
- **エラーを早期に捕捉**: 検証が変更を適用する前に問題を発見
- **機械的に検証可能**: スクリプトが客観的な検証を提供
- **可逆的な計画**: Claudeは元のファイルに触れることなく計画を反復できる
- **明確なデバッグ**: エラーメッセージが特定の問題を指摘

**使用タイミング**: バッチ操作、破壊的変更、複雑な検証ルール、高リスクの操作

**実装のヒント**: 検証スクリプトを詳細なエラーメッセージで冗長にする（例: "フィールド 'signature_date' が見つかりません。利用可能なフィールド: customer_name, order_total, signature_date_signed"）ことで、Claudeが問題を修正するのを助けます。

---

### パッケージ依存関係

Skillsはコード実行環境で実行され、プラットフォーム固有の制限があります:

- **claude.ai**: npmとPyPIからパッケージをインストールでき、GitHubリポジトリからプルできる
- **Anthropic API**: ネットワークアクセスなし、ランタイムパッケージインストールなし

SKILL.mdに必要なパッケージをリストし、コード実行ツールのドキュメントで利用可能かを確認してください。

---

### ランタイム環境

Skillsはファイルシステムアクセス、bashコマンド、コード実行機能を持つコード実行環境で実行されます。

**Claudeが Skillsにアクセスする方法**:

1. **メタデータがプリロード**: 起動時、すべてのSkillsのYAMLフロントマターからnameとdescriptionがシステムプロンプトに読み込まれる
2. **ファイルはオンデマンドで読み込み**: Claudeは必要に応じてbash Readツールを使用してSKILL.mdや他のファイルにアクセス
3. **スクリプトは効率的に実行**: ユーティリティスクリプトは完全な内容をコンテキストに読み込むことなくbash経由で実行可能。スクリプトの出力のみがトークンを消費
4. **大きなファイルへのコンテキストペナルティなし**: 参照ファイル、データ、ドキュメントは実際に読み込まれるまでコンテキストトークンを消費しない

**作成への影響**:

- **ファイルパスが重要**: Claudeはskillディレクトリをファイルシステムのようにナビゲート。フォワードスラッシュ（`reference/guide.md`）を使用、バックスラッシュは使わない
- **ファイルに説明的な名前を付ける**: 内容を示す名前を使用: `form_validation_rules.md`、`doc2.md`ではない
- **発見のために整理**: ドメインまたは機能でディレクトリを構造化
  - 良い: `reference/finance.md`, `reference/sales.md`
  - 悪い: `docs/file1.md`, `docs/file2.md`
- **包括的なリソースをバンドル**: 完全なAPIドキュメント、広範な例、大きなデータセットを含める。アクセスされるまでコンテキストペナルティなし
- **決定論的操作にはスクリプトを優先**: 検証コードを生成するようClaudeに依頼するより`validate_form.py`を書く
- **実行意図を明確に**:
  - "analyze_form.pyを実行してフィールドを抽出"（実行）
  - "抽出アルゴリズムはanalyze_form.pyを参照"（参照として読む）
- **ファイルアクセスパターンをテスト**: 実際のリクエストでテストして、Claudeがディレクトリ構造をナビゲートできることを確認

---

### MCP ツール参照

SkillがMCP（Model Context Protocol）ツールを使用する場合、「ツールが見つかりません」エラーを避けるため、常に完全修飾ツール名を使用してください。

**形式**: `ServerName:tool_name`

**例**:
```markdown
テーブルスキーマを取得するにはBigQuery:bigquery_schemaツールを使用。
イシューを作成するにはGitHub:create_issueツールを使用。
```

ここで:
- `BigQuery`と`GitHub`はMCPサーバー名
- `bigquery_schema`と`create_issue`はそれらのサーバー内のツール名

サーバープレフィックスがないと、特に複数のMCPサーバーが利用可能な場合、Claudeがツールを見つけられない可能性があります。

---

## 評価とテスト

### 評価駆動開発

**広範なドキュメントを書く前に評価を作成**。これにより、Skillが想像上の問題ではなく実際の問題を解決することを保証します。

**評価駆動開発**:

1. **ギャップを特定**: Skillなしで代表的なタスクでClaudeを実行。特定の失敗や欠けているコンテキストを文書化
2. **評価を作成**: これらのギャップをテストする3つのシナリオを構築
3. **ベースラインを確立**: Skillなしでのパフォーマンスを測定
4. **最小限の指示を書く**: ギャップに対処し評価に合格するのに十分な内容のみを作成
5. **反復**: 評価を実行し、ベースラインと比較して改善

**評価構造**:

```json
{
  "skills": ["pdf-processing"],
  "query": "このPDFファイルからすべてのテキストを抽出し、output.txtに保存",
  "files": ["test-files/document.pdf"],
  "expected_behavior": [
    "適切なPDF処理ライブラリまたはコマンドラインツールを使用してPDFファイルを正常に読み取る",
    "ページを欠落させることなくドキュメントのすべてのページからテキストコンテンツを抽出",
    "抽出されたテキストを明確で読みやすい形式でoutput.txtという名前のファイルに保存"
  ]
}
```

このアプローチは、実際に現れる可能性のない要件を予測するのではなく、実際の問題を解決することを保証します。

---

### Claudeと反復的にSkillsを開発

**最も効果的なSkill開発プロセスはClaude自身を含む**。一つのClaudeインスタンス（「Claude A」）でSkillを作成し、他のインスタンス（「Claude B」）で使用します。Claude AがSkillの設計と改善を助け、Claude Bが実際のタスクでテストします。

**新しいSkillの作成**:

1. **Skillなしでタスクを完了**: Claude Aと通常のプロンプトで問題を解決。作業中に、コンテキスト、好み、手続き的知識を自然に提供します。繰り返し提供する情報に注目します。

2. **再利用可能なパターンを特定**: タスク完了後、類似の将来のタスクに有用なコンテキストを特定します。

3. **Claude A に Skill を作成するよう依頼**: 「使用したこのBigQuery分析パターンを捉えたSkillを作成して。テーブルスキーマ、命名規則、テストアカウントのフィルタリングルールを含めて。」

   **ヒント**: ClaudeモデルはSkillフォーマットと構造をネイティブに理解します。ClaudeにSkillを作成させるために特別なシステムプロンプトや「skillを書くskill」は不要です。単にClaudeにSkillを作成するよう依頼すれば、適切に構造化されたSKILL.mdコンテンツと適切なフロントマターを生成します。

4. **簡潔さをレビュー**: Claude Aが不要な説明を追加していないか確認。「勝率の意味についての説明を削除して - Claudeはそれを既に知っています。」と依頼します。

5. **情報アーキテクチャを改善**: より効果的にコンテンツを整理するようClaude Aに依頼。例: 「テーブルスキーマが別の参照ファイルにあるように整理して。後でテーブルを追加するかもしれません。」

6. **類似のタスクでテスト**: Claude B（Skillが読み込まれた新しいインスタンス）で関連するユースケースでSkillを使用。Claude Bが適切な情報を見つけ、ルールを正しく適用し、タスクを成功裏に処理するかを観察します。

7. **観察に基づいて反復**: Claude Bが苦労したり何かを見逃したりした場合、具体的な内容でClaude Aに戻ります: 「ClaudeがこのSkillを使用した時、Q4の日付フィルタリングを忘れました。日付フィルタリングパターンについてのセクションを追加すべきですか?」

**既存のSkillsの反復**:

同じ階層パターンがSkillsの改善時も続きます。以下を交互に行います:
- **Claude Aと作業**（Skillの改善を助ける専門家）
- **Claude Bでテスト**（実際の作業を実行するためにSkillを使用するエージェント）
- **Claude Bの動作を観察**し、洞察をClaude Aに持ち帰る

1. **実際のワークフローでSkillを使用**: Claude B（Skillが読み込まれた状態）に実際のタスクを与える（テストシナリオではない）

2. **Claude Bの動作を観察**: 苦労する箇所、成功する箇所、予期しない選択をする箇所に注目

   **観察例**: 「Claude Bに地域営業レポートを依頼した時、クエリを書いたがテストアカウントのフィルタリングを忘れた。Skillはこのルールに言及しているのに。」

3. **Claude Aに改善を依頼**: 現在のSKILL.mdと観察した内容を共有。「Claude Bが地域レポートを依頼された時にテストアカウントのフィルタリングを忘れたことに気づきました。Skillはフィルタリングについて言及していますが、十分に目立たないのかもしれません?」

4. **Claude Aの提案をレビュー**: Claude Aはルールをより目立たせるための再編成、「フィルタする」ではなく「必ずフィルタ」のようなより強い言葉の使用、またはワークフローセクションの再構築を提案するかもしれません。

5. **変更を適用してテスト**: Claude Aの改善でSkillを更新し、Claude Bで類似のリクエストで再度テスト

6. **使用に基づいて繰り返す**: 新しいシナリオに遭遇するごとにこの観察-改善-テストサイクルを続けます。各反復は仮定ではなく実際のエージェントの動作に基づいてSkillを改善します。

**チームフィードバックの収集**:

1. チームメイトとSkillsを共有し、使用を観察
2. 質問: Skillは期待通りに発動するか? 指示は明確か? 何が欠けているか?
3. フィードバックを取り入れて自分の使用パターンの盲点に対処

**なぜこのアプローチが機能するか**: Claude Aはエージェントのニーズを理解し、あなたがドメイン専門知識を提供し、Claude Bが実際の使用を通じてギャップを明らかにし、反復的な改善が仮定ではなく観察された動作に基づいてSkillsを改善します。

---

### ClaudeがSkillsをナビゲートする方法を観察

Skillsを反復する際、Claudeが実際にどのように使用するかに注意を払います。以下を観察します:

- **予期しない探索パス**: Claudeが予想しない順序でファイルを読むか? これは構造が思ったほど直感的でないことを示すかもしれません
- **見逃された接続**: Claudeが重要なファイルへの参照をたどらないか? リンクがより明示的または目立つ必要があるかもしれません
- **特定セクションへの過度な依存**: Claudeが同じファイルを繰り返し読む場合、そのコンテンツはメインのSKILL.mdにあるべきかを検討
- **無視されるコンテンツ**: Claudeがバンドルされたファイルにアクセスしない場合、不要またはメイン指示で不十分にシグナル化されているかもしれません

仮定ではなく、これらの観察に基づいて反復します。Skillのメタデータの'name'と'description'は特に重要です。Claudeはこれらを使用して、現在のタスクに応じてSkillを発動すべきかを決定します。Skillが何をするか、いつ使用すべきかを明確に記述してください。

---

## アンチパターン

### Windowsスタイルのパスを避ける

常にファイルパスにフォワードスラッシュを使用（Windowsでも）:

- ✓ **良い**: `scripts/helper.py`, `reference/guide.md`
- ✗ **避ける**: `scripts\helper.py`, `reference\guide.md`

Unixスタイルのパスはすべてのプラットフォームで機能しますが、WindowsスタイルのパスはUnixシステムでエラーを引き起こします。

---

### 多すぎる選択肢の提供を避ける

必要でない限り複数のアプローチを提示しない:

````markdown
✗ 悪い例（混乱を招く）:
「pypdf、pdfplumber、PyMuPDF、pdf2image、または...を使用できます」

✓ 良い例（デフォルトを提供）:
「テキスト抽出にはpdfplumberを使用:
```python
import pdfplumber
```

OCRが必要なスキャンPDFには、pdf2imageとpytesseractを使用。」
````

---

### 時間依存情報を避ける

古くなる情報を含めない:

````markdown
✗ 悪い例（時間依存）:
「2025年8月以前の場合は古いAPIを使用。2025年8月以降は新しいAPIを使用。」

✓ 良い例:
## 現在の方法

v2 APIエンドポイントを使用: `api.example.com/v2/messages`

## 古いパターン

<details>
<summary>レガシーv1 API（2025-08非推奨）</summary>

v1 APIは使用: `api.example.com/v1/messages`

このエンドポイントはサポートされていません。
</details>
````

---

### 一貫した用語を使用

一つの用語を選び、Skill全体で使用:

✓ **良い - 一貫性**:
- 常に「APIエンドポイント」
- 常に「フィールド」
- 常に「抽出」

✗ **悪い - 不一貫性**:
- 「APIエンドポイント」「URL」「APIルート」「パス」を混在
- 「フィールド」「ボックス」「要素」「コントロール」を混在
- 「抽出」「プル」「取得」「検索」を混在

一貫性はClaudeが指示を理解し従うのを助けます。

---

### ツールのインストールを仮定しない

パッケージが利用可能であることを仮定しない:

````markdown
✗ 悪い例（インストールを仮定）:
「pdfライブラリを使用してファイルを処理。」

✓ 良い例（依存関係について明示的）:
「必要なパッケージをインストール: `pip install pypdf`

次に使用:
```python
from pypdf import PdfReader
reader = PdfReader("file.pdf")
```」
````

---

## 技術的な注意事項

### YAML フロントマター要件

SKILL.mdのフロントマターは`name`と`description`フィールドが特定の検証ルールで必要:

**name**:
- 最大64文字
- 小文字/数字/ハイフンのみ
- XMLタグ不可
- 予約語不可（"anthropic", "claude"）

**description**:
- 最大1024文字
- 空欄不可
- XMLタグ不可
- 三人称で記述
- 具体的なトリガーキーワードを含める

---

### トークンバジェット

最適なパフォーマンスのため、SKILL.md本文を500行以内に保ちます。コンテンツがこれを超える場合、前述の段階的情報開示パターンを使用して別ファイルに分割します。

---

## まとめ

効果的なSkill作成の鍵:

1. **簡潔さ**: Claudeが既に知っていることは説明しない
2. **段階的開示**: メインファイルを簡潔に保ち、詳細は参照ファイルに
3. **適切な自由度**: タスクの脆弱性に応じて指示の具体性を調整
4. **明確なワークフロー**: 複雑なタスクにステップバイステップのガイダンス
5. **フィードバックループ**: 品質重視タスクのための検証と反復
6. **具体的な例**: 抽象的な説明より実際の例
7. **評価駆動**: 広範なドキュメントの前にテストケースを作成
8. **反復的改善**: 実際の使用を観察し、Claude自身とSkillを改善
