# Skill作成例

このファイルには、実際のSkill作成の例とベストプラクティスの適用例が含まれています。

## 目次

- 例1: シンプルなコードレビューSkill
- 例2: Git コミットメッセージ生成Skill
- 例3: PDF処理Skill（段階的情報開示付き）
- Before/After: よくある改善例

---

## 例1: シンプルなコードレビューSkill

### 完成版

````markdown
---
name: reviewing-code
description: コードレビューを実施し、バグ、セキュリティ問題、改善提案を提供。コードレビュー、PR確認、品質チェックに言及された時に使用。
---

# Code Review

## レビュープロセス

このチェックリストをコピーして進捗追跡:

```
レビュー進捗:
- [ ] 1. コード構造と整理を分析
- [ ] 2. バグやエッジケースを確認
- [ ] 3. 可読性と保守性の改善を提案
- [ ] 4. プロジェクト規約への準拠を検証
```

### 1. コード構造と整理を分析

以下を確認:
- 適切な責任分離
- 命名の明確性
- モジュール構成

### 2. バグやエッジケースを確認

特に注目:
- NULLや未定義値の扱い
- 境界値条件
- エラーハンドリングの完全性
- 競合状態やタイミング問題

### 3. 可読性と保守性の改善を提案

評価項目:
- コードの明確性
- 過度な複雑さ
- 重複コード
- コメントの必要性（コードが自己説明的でない場合）

### 4. プロジェクト規約への準拠を検証

確認事項:
- コーディングスタイル
- アーキテクチャパターン
- テストカバレッジ
- ドキュメント要件

## フィードバックフォーマット

レビューコメントは以下の形式で提供:

```markdown
## コードレビュー: [ファイル名またはPR番号]

### 🐛 バグ/問題

**[場所]**: [ファイル名:行番号]
- 問題: [具体的な問題の説明]
- 推奨: [修正方法]

### 💡 改善提案

**[場所]**: [ファイル名:行番号]
- 現状: [現在の実装]
- 提案: [改善案]
- 理由: [なぜこの改善が有益か]

### ✅ 良い点

- [優れた実装の具体例]

### 📋 サマリー

- 重大な問題: [数]
- 改善提案: [数]
- 総合評価: [承認/条件付き承認/要修正]
```

## レビューの優先順位

1. **セキュリティ脆弱性** (最優先)
   - SQLインジェクション
   - XSS
   - 認証/認可の問題
   - 機密情報の露出

2. **機能的バグ** (高優先度)
   - ロジックエラー
   - データ損失のリスク
   - 正しくない計算

3. **パフォーマンス問題** (中優先度)
   - N+1クエリ
   - 不要なループ
   - メモリリーク

4. **コード品質** (低優先度)
   - スタイルの不一致
   - 小さなリファクタリング機会
````

**なぜこれが効果的か**:
- ✅ 簡潔: 必要な情報のみを含む
- ✅ 構造化: チェックリストでワークフローを明確化
- ✅ 具体的: 抽象的な「コードを確認」ではなく、何を確認するか明示
- ✅ 優先順位付き: レビューの重点が明確

---

## 例2: Git コミットメッセージ生成Skill

### 完成版

````markdown
---
name: writing-commit-messages
description: git diffを分析して説明的なコミットメッセージを生成。コミットメッセージ、git commit、変更の説明に言及された時に使用。
---

# Git Commit Message Generator

## 基本プロセス

1. `git diff --staged` を実行して変更を確認
2. 変更の性質を分析（新機能、バグ修正、リファクタリングなど）
3. 以下のフォーマットに従ってメッセージを生成

## コミットメッセージフォーマット

```
<type>(<scope>): <subject>

<body>

<footer>
```

### Type（必須）

- `feat`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメントのみの変更
- `style`: コードの意味に影響しない変更（空白、フォーマットなど）
- `refactor`: バグ修正や機能追加ではないコード変更
- `perf`: パフォーマンス改善
- `test`: テストの追加や修正
- `chore`: ビルドプロセスや補助ツールの変更

### Scope（オプション）

変更の範囲を示す:
- コンポーネント名（`auth`, `api`, `ui`）
- ファイル名（`user-service`, `config`）
- 機能名（`login`, `checkout`）

### Subject（必須）

- 50文字以内
- 命令形を使用（「追加した」ではなく「追加」）
- 先頭を小文字にしない（日本語の場合は自然な形）
- 末尾にピリオドを付けない

### Body（オプション、複雑な変更には推奨）

- 「何を」ではなく「なぜ」を説明
- 各行72文字以内
- 複数の変更がある場合は箇条書き

### Footer（オプション）

- 破壊的変更（`BREAKING CHANGE:`）
- Issue参照（`Closes #123`, `Refs #456`）

## 例

### 例1: シンプルな機能追加

```
feat(auth): JWTベース認証を実装

ログインエンドポイントとトークン検証ミドルウェアを追加
```

### 例2: バグ修正

```
fix(reports): タイムゾーン変換の日付フォーマットを修正

レポート生成全体でUTCタイムスタンプを一貫して使用することで、
異なるタイムゾーンでの日付表示の不整合を解消

Fixes #234
```

### 例3: 複雑なリファクタリング

```
refactor(api): エラーハンドリングを統一

- すべてのエンドポイントで一貫したエラーレスポンス形式を使用
- カスタムエラークラスを導入してエラー分類を改善
- エラーログのフォーマットを標準化

これにより、クライアント側のエラー処理が簡素化され、
デバッグが容易になる

BREAKING CHANGE: エラーレスポンスの形式が変更されたため、
クライアント側のエラーハンドリングコードの更新が必要
```

### 例4: 複数の小さな変更

```
chore: 依存関係を更新し、エラーハンドリングをリファクタリング

- lodashを4.17.21にアップグレード（セキュリティ修正）
- すべてのエンドポイントでエラーレスポンス形式を統一
- 古いテストヘルパーを削除
```

## 分析のポイント

変更を分析する際は以下を考慮:

1. **変更の本質**: 何が変わったか（新機能、修正、改善）
2. **影響範囲**: どのコンポーネント/モジュールが影響を受けるか
3. **動機**: なぜこの変更が必要だったか
4. **破壊的変更**: 既存の機能を壊す可能性はあるか

## ワークフロー

```bash
# 1. ステージングされた変更を確認
git diff --staged

# 2. メッセージを生成（この Skill を使用）

# 3. コミット
git commit -m "生成されたメッセージ"
```
````

**なぜこれが効果的か**:
- ✅ 明確な例: 抽象的な説明ではなく、5つの具体例を提供
- ✅ 構造化ガイダンス: 各要素（type, scope, subject）を明確に定義
- ✅ 判断基準: 「分析のポイント」で何を考慮すべきか明示
- ✅ 簡潔: 余分な説明なしで必要な情報のみ

---

## 例3: PDF処理Skill（段階的情報開示付き）

### SKILL.md（メインファイル）

````markdown
---
name: processing-pdfs
description: PDFからテキストとテーブルを抽出、フォーム入力、文書結合を実行。PDF、フォーム、文書抽出に言及された時に使用。
---

# PDF Processing

## クイックスタート

基本的なテキスト抽出:

```python
import pdfplumber

with pdfplumber.open("file.pdf") as pdf:
    text = pdf.pages[0].extract_text()
```

## 主要機能

**テキスト抽出**: pdfplumberで通常のPDFから抽出
**テーブル抽出**: 構造化データの抽出方法は [TABLES.md](TABLES.md) を参照
**フォーム入力**: 完全なガイドは [FORMS.md](FORMS.md) を参照
**OCR処理**: スキャンPDFの処理は [OCR.md](OCR.md) を参照

## 必要なパッケージ

```bash
pip install pdfplumber==0.10.3
```

フォーム入力には追加で:
```bash
pip install pypdf==3.17.1
```

OCRには追加で:
```bash
pip install pdf2image pytesseract
# macOSの場合: brew install tesseract
```

## 基本的なワークフロー

```
PDF処理進捗:
- [ ] 1. PDFタイプを判定（テキスト/スキャン）
- [ ] 2. 適切な抽出方法を選択
- [ ] 3. データを抽出
- [ ] 4. 出力を検証
```

### 1. PDFタイプを判定

```python
import pdfplumber

with pdfplumber.open("file.pdf") as pdf:
    text = pdf.pages[0].extract_text()
    if text and len(text.strip()) > 50:
        print("テキストPDF")
    else:
        print("スキャンPDF - OCRが必要")
```

### 2-4. 適切な方法を選択して処理

- **テキストPDF**: 上記のクイックスタートを使用
- **テーブル**: [TABLES.md](TABLES.md) のガイドに従う
- **フォーム**: [FORMS.md](FORMS.md) のワークフローに従う
- **スキャン**: [OCR.md](OCR.md) の手順に従う

## トラブルシューティング

**問題: テキストが抽出できない**
解決: スキャンPDFの可能性あり。OCR.mdを参照

**問題: テーブルの構造が崩れる**
解決: TABLES.mdの高度な抽出方法を試す
````

### FORMS.md（参照ファイル）

````markdown
# PDFフォーム入力ガイド

## 目次
- フォーム入力ワークフロー
- ユーティリティスクリプト
- フィールドタイプ別の処理
- トラブルシューティング

## フォーム入力ワークフロー

このチェックリストをコピーして進捗追跡:

```
フォーム入力進捗:
- [ ] ステップ1: フォームを分析（analyze_form.py）
- [ ] ステップ2: フィールドマッピングを作成（fields.json編集）
- [ ] ステップ3: マッピングを検証（validate_fields.py）
- [ ] ステップ4: フォームを入力（fill_form.py）
- [ ] ステップ5: 出力を検証（verify_output.py）
```

### ステップ1: フォームを分析

```bash
python scripts/analyze_form.py input.pdf
```

これにより `fields.json` が生成される:

```json
{
  "customer_name": {"type": "text", "page": 0, "x": 100, "y": 200},
  "order_date": {"type": "text", "page": 0, "x": 100, "y": 250},
  "signature": {"type": "signature", "page": 1, "x": 150, "y": 500}
}
```

### ステップ2: フィールドマッピングを作成

`fields.json` を編集して値を追加:

```json
{
  "customer_name": {
    "type": "text",
    "page": 0,
    "x": 100,
    "y": 200,
    "value": "田中太郎"
  },
  "order_date": {
    "type": "text",
    "page": 0,
    "x": 100,
    "y": 250,
    "value": "2025-01-22"
  }
}
```

### ステップ3: マッピングを検証

```bash
python scripts/validate_fields.py fields.json
```

**検証エラーの場合**: エラーメッセージを確認し、fields.jsonを修正して再検証。

### ステップ4: フォームを入力

検証成功後のみ実行:

```bash
python scripts/fill_form.py input.pdf fields.json output.pdf
```

### ステップ5: 出力を検証

```bash
python scripts/verify_output.py output.pdf
```

検証失敗の場合はステップ2に戻る。

## フィールドタイプ別の処理

### テキストフィールド

```json
{
  "field_name": {
    "type": "text",
    "value": "入力するテキスト"
  }
}
```

### チェックボックス

```json
{
  "agree_terms": {
    "type": "checkbox",
    "value": true
  }
}
```

### 日付フィールド

```json
{
  "birth_date": {
    "type": "date",
    "value": "1990-01-15",
    "format": "YYYY-MM-DD"
  }
}
```

## ユーティリティスクリプト詳細

### analyze_form.py

**機能**: PDFフォームのすべてのフィールドを抽出

**使用法**:
```bash
python scripts/analyze_form.py <input.pdf> [--output fields.json]
```

**出力**: フィールド名、タイプ、座標を含むJSON

### validate_fields.py

**機能**: フィールドマッピングの妥当性を検証

**使用法**:
```bash
python scripts/validate_fields.py <fields.json>
```

**検証項目**:
- 必須フィールドの存在
- 値のタイプ
- 座標の範囲
- フォーマットの正しさ

### fill_form.py

**機能**: マッピングに基づいてPDFフォームを入力

**使用法**:
```bash
python scripts/fill_form.py <input.pdf> <fields.json> <output.pdf>
```

### verify_output.py

**機能**: 出力PDFが正しく生成されたか検証

**使用法**:
```bash
python scripts/verify_output.py <output.pdf>
```

## トラブルシューティング

**エラー: フィールドが見つからない**
- analyze_form.py を再実行してフィールド名を確認
- PDFがフォーム対応か確認

**エラー: 値の型が不正**
- validate_fields.py のエラーメッセージで期待される型を確認
- fields.json の value を修正

**エラー: 署名フィールドの処理失敗**
- 署名は画像として挿入する必要がある
- 画像パスを value に指定: `"value": "path/to/signature.png"`
````

**なぜこれが効果的か**:
- ✅ 段階的情報開示: SKILL.mdは簡潔で、詳細はFORMS.mdに分離
- ✅ 明確なワークフロー: チェックリストで各ステップを追跡
- ✅ フィードバックループ: 検証失敗時の対応を明示
- ✅ 実用的なスクリプト: 各スクリプトの目的と使用法を明確化

---

## Before/After: よくある改善例

### 改善1: 過剰な説明を削除

**Before（冗長）**:

```markdown
PDFファイルは、Portable Document Formatの略で、文書を
プラットフォームに依存せずに表示するための一般的なファイル
形式です。PDFからテキストを抽出するには、ライブラリを使用
する必要があります。利用可能なライブラリは多数ありますが、
pdfplumberは使いやすく、ほとんどのケースに対応できるため
推奨します。まず、pipを使用してインストールする必要があります...
```

**After（簡潔）**:

```markdown
pdfplumberでテキスト抽出:

\`\`\`python
import pdfplumber
with pdfplumber.open("file.pdf") as pdf:
    text = pdf.pages[0].extract_text()
\`\`\`
```

**改善点**: Claudeが既に知っている基本情報を削除し、必要なコードのみを提供

---

### 改善2: 選択肢を絞る

**Before（混乱を招く）**:

```markdown
PDFを処理するには、pypdf、pdfplumber、PyMuPDF、pdf2image、
camelot、tabula-py、pdfminer、または他の多くのライブラリを
使用できます。それぞれに長所と短所があります...
```

**After（明確）**:

```markdown
テキスト抽出にはpdfplumberを使用:

\`\`\`python
import pdfplumber
\`\`\`

スキャンPDFのOCRには、pdf2imageとpytesseractを使用。
```

**改善点**: デフォルトの選択肢を提供し、特別なケースのみ代替案を提示

---

### 改善3: 抽象的な指示を具体例に置き換え

**Before（抽象的）**:

```markdown
コードを分析して、潜在的な問題や改善の機会を特定してください。
品質、パフォーマンス、セキュリティの観点から評価してください。
```

**After（具体的）**:

```markdown
## コード分析チェックリスト

### セキュリティ
- [ ] SQLインジェクションの脆弱性はないか
- [ ] XSSの可能性はないか
- [ ] 機密情報がハードコードされていないか

### パフォーマンス
- [ ] N+1クエリはないか
- [ ] 不要なループはないか
- [ ] 適切にキャッシュされているか

### 品質
- [ ] エラーハンドリングは適切か
- [ ] 命名は明確か
- [ ] 重複コードはないか
```

**改善点**: 「分析」という抽象的な指示を、具体的なチェック項目に変換

---

### 改善4: 時間依存情報を削除

**Before（時間依存）**:

```markdown
2025年8月以前の場合は古いAPIを使用してください:
\`\`\`python
api.v1.process()
\`\`\`

2025年8月以降の場合は新しいAPIを使用してください:
\`\`\`python
api.v2.process()
\`\`\`
```

**After（時間非依存）**:

```markdown
## 現在の方法

v2 APIを使用:

\`\`\`python
api.v2.process()
\`\`\`

## 古いパターン

<details>
<summary>レガシーv1 API（2025-08非推奨）</summary>

\`\`\`python
api.v1.process()
\`\`\`

v1 APIはサポート終了しました。
</details>
```

**改善点**: 時間依存の条件分岐を削除し、現在の方法を強調。レガシー情報は折りたたみ可能なセクションに

---

## 例から学ぶポイント

1. **簡潔さ**: Claudeが既に知っていることは説明しない
2. **具体性**: 抽象的な指示より具体的なチェックリストや例
3. **構造化**: ワークフローとチェックリストで明確なステップ
4. **段階的開示**: メインファイルは簡潔に、詳細は参照ファイルに
5. **フィードバックループ**: エラー時の対応を明示
6. **一貫性**: 用語、フォーマット、スタイルを統一
7. **テンプレートと例**: 期待される出力形式を明示
